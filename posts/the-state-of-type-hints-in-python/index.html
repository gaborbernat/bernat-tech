<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Bernát Gábor"><meta name=description content="One of the main selling points for Python is that it is dynamically-typed. There is no plan to change this. Nevertheless, in September 2014 Guido van Rossum (Python BDFL) created a python enhancement proposal (PEP-484) to add type hints to Python. It has been released for general usage a year later, in September 2015, as part of Python 3.5.0. Twenty-five years into its existence now there was a standard way to add type information to Python code."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="the state of type hints in Python"><meta name=twitter:description content="One of the main selling points for Python is that it is dynamically-typed. There is no plan to change this. Nevertheless, in September 2014 Guido van Rossum (Python BDFL) created a python enhancement proposal (PEP-484) to add type hints to Python. It has been released for general usage a year later, in September 2015, as part of Python 3.5.0. Twenty-five years into its existence now there was a standard way to add type information to Python code."><meta property="og:title" content="the state of type hints in Python"><meta property="og:description" content="One of the main selling points for Python is that it is dynamically-typed. There is no plan to change this. Nevertheless, in September 2014 Guido van Rossum (Python BDFL) created a python enhancement proposal (PEP-484) to add type hints to Python. It has been released for general usage a year later, in September 2015, as part of Python 3.5.0. Twenty-five years into its existence now there was a standard way to add type information to Python code."><meta property="og:type" content="article"><meta property="og:url" content="https://bernat.tech/posts/the-state-of-type-hints-in-python/"><meta property="article:published_time" content="2018-05-30T09:51:55+00:00"><meta property="article:modified_time" content="2018-05-30T09:51:55+00:00"><title>the state of type hints in Python · Tech articles by Bernát Gábor</title><link rel=canonical href=https://bernat.tech/posts/the-state-of-type-hints-in-python/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=/css/coder.min.f01c647a0d25b40da992a37c3376291185eed8a50ced8c26cc2c0bcfe38c97df.css integrity="sha256-8Bxkeg0ltA2pkqN8M3YpEYXu2KUM7YwmzCwLz+OMl98=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.css><link rel=icon type=image/png href=/img/android-chrome-192x192.png sizes=32x32><link rel=icon type=image/png href=/img/android-chrome-192x192.png sizes=16x16><link rel=apple-touch-icon href=/img/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=/img/android-chrome-192x192.png><script src=https://twemoji.maxcdn.com/v/latest/twemoji.min.js crossorigin=anonymous></script><meta name=generator content="Hugo 0.78.2"></head><body class=colorscheme-auto onload=twemoji.parse(document.body);><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Tech articles by Bernát Gábor</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>the state of type hints in Python</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2018-05-30T09:51:55Z>May 30, 2018</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>27-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/tags/mypy/>mypy</a>
<span class=separator>•</span>
<a href=/tags/python/>python</a>
<span class=separator>•</span>
<a href=/tags/types/>types</a>
<span class=separator>•</span>
<a href=/tags/type-hint/>type-hint</a></div></div></header><div><p>One of the main selling points for Python is that it is dynamically-typed. There is no plan to change this.
Nevertheless, in September 2014 <a href=https://twitter.com/gvanrossum>Guido van Rossum</a> (Python
<a href=https://en.wikipedia.org/wiki/Benevolent_dictator_for_life>BDFL</a>) created a python enhancement proposal
(<a href=https://www.python.org/dev/peps/pep-0484>PEP-484</a>) to add type hints to Python. It has been released for general
usage a year later, in September 2015, as part of Python 3.5.0.
<a href=http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html>Twenty-five years into its existence</a> now
there was a standard way to add type information to Python code. In this blog post, I&rsquo;ll explore how the system matured,
how you can use it and what&rsquo;s next for type hints.</p><p>Disclaimer: throughout this blog post, you&rsquo;ll see many seals and penguin pictures, the reason for this is mostly my
admiration for these animals; and hey nothing like some cute animals to help digest some complex topics, not?</p><h1 id=why-do-we-need-this>Why do we need this?</h1><h2 id=what-it-was-designed-to-do>What it was designed to do?</h2><p>First, let&rsquo;s see why do we need type hints in Python. There are multiple advantages of this, and I&rsquo;ll try to enumerate
it in their order of importance:</p><h3 id=1-easier-to-reason-about-code>1. Easier to reason about code</h3><p>Knowing the type of the parameters makes it a lot easier to understand and maintain a code base. For example, let&rsquo;s
assume you have a function. While we do know the parameters types at the time of creating the function, a few months
down the line this is no longer the case. Having stated the types of all parameters and return types right beside the
code can speed up significantly the time required to catch up with a code snippet. Always remember that code you read
code a lot more often than you write it. Therefore you should optimise for ease of reading.</p><p>Having type hints informs you of what parameter types you need to pass on when calling a function, and when you need to
extend/modify the function tells you about the type of data you get both as input and output. For example, imagine the
following send request function,</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> send_request(request_data : Any,
                 headers: Optional[Dict[str, str]],
                 user_id: Optional[UserId] = None,
                 as_json: bool = True):
    ...
</code></pre></div><p>Just looking at the signature of this I know that while the <code>request_data</code> could be anything, the <code>headers</code> content is a
dictionary of strings. The user information is optional (defaulting to <code>None</code>) or it needs to be whatever <code>UserId</code>
encodes it too. Also the contract for <code>as_json</code> is that it needs to be always a boolean value, being a flag essentially
even though the name might not suggest that at first.</p><p>The truth is many of us already understand that type information is essential, however in lack of better options until
now this was often mentioned inside the docstring. The type hint system moves this closer to the interface of the
function and provides a well-defined way to declare complex type requirements. Building linters that can check these
type hint constraints ensure that they never become out of date, granted that you run them after every code change.</p><h3 id=2easier-refactoring>2.Easier refactoring</h3><p>Type hints make it trivial to find where a given class is used when you&rsquo;re trying to refactor your code base. While many
IDEs already have some heuristic in place to achieve this, type hints allow them to have <code>100%</code> detection and accuracy
ratio. Generally offers a smoother and more accurate detection of how types run through your code. Remember while
dynamic typing means any variable can become any of types, all your variables have at all time one and only one type.
Type system still is very much a core component of programming, remember all the time you&rsquo;ve used <code>isinstance</code> to drive
your application logic.</p><h3 id=3-easier-to-use-libraries>3. Easier to use libraries</h3><p>Having type hints mean IDEs can have a more accurate and smarter suggestion engine. Now when you invoke auto-complete,
the IDE knows with complete confidence what methods/attributes are available on an object. Furthermore, if the user
tries to call something which is non-existent or passes arguments of an incorrect type the IDE can instantly warn about
it.</p><h3 id=4-type-linters>4. Type linters</h3><p><img src=/content/images/2018/05/type_missmatch.jpg alt=type_missmatch> While the IDE suggesting incorrect argument types is nice,
an extension of this is to have a linter tool that makes sure that type wise the logic of your application is sound.
Running this tool can help you catch bugs early on (e.g. in the example that follows the input must be of type <code>str</code>,
passing in <code>None</code> throws an exception):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> transform(arg):
    <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;transformed value {}&#39;</span>.format(arg.upper())

transform(None) <span style=font-style:italic># if arg would be type hinted as str the type linter could warn that this is an invalid call</span>
</code></pre></div><p>While in this trivial case, some could argue that it&rsquo;s easy to see the mismatch, remember this works in more complicated
cases too, where such mismatches get harder and harder to see; such as nested function calls:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> construct(param=None):
    <span style=font-weight:700>return</span> None <span style=font-weight:700>if</span> param <span style=font-weight:700>is</span> None <span style=font-weight:700>else</span> <span style=font-style:italic>&#39;&#39;</span>

<span style=font-weight:700>def</span> append(arg):
    <span style=font-weight:700>return</span> arg + <span style=font-style:italic>&#39; appended&#39;</span>

transform( append( construct() ) )
</code></pre></div><p>While there are more and more linters out there, the reference implementation of the Python type checking is
<a href=http://mypy-lang.org/>mypy</a>. mypy is a Python command line application, making it easy to integrate into a continuous
integration pipeline.</p><h3 id=5-runtime-data-validation>5. Runtime data validation</h3><p>Type hints can be used to validate at runtime to ensure that the caller does not break the contract of methods. It is no
longer needed to start your function with a long list of type asserts; instead, use a framework that re-uses type hints
and automatically checks that they are meet before your business logic runs (for example with
<a href=https://github.com/samuelcolvin/pydantic>pydantic</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>datetime</span> <span style=font-weight:700>import</span> datetime
<span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List
<span style=font-weight:700>from</span> <span style=font-weight:700>pydantic</span> <span style=font-weight:700>import</span> BaseModel, ValidationError

<span style=font-weight:700>class</span> <span style=font-weight:700>User</span>(BaseModel):
    id: int
    name = <span style=font-style:italic>&#39;John Doe&#39;</span>
    signup_ts: datetime = None
    friends: List[int] = []

external_data = {<span style=font-style:italic>&#39;id&#39;</span>: <span style=font-style:italic>&#39;123&#39;</span>, <span style=font-style:italic>&#39;signup_ts&#39;</span>: <span style=font-style:italic>&#39;2017-06-01 12:22&#39;</span>,
                 <span style=font-style:italic>&#39;friends&#39;</span>: [1, 2, 3]}
user = User(**external_data)

<span style=font-weight:700>try</span>:
    User(signup_ts=<span style=font-style:italic>&#39;broken&#39;</span>, friends=[1, 2, <span style=font-style:italic>&#39;not number&#39;</span>])
<span style=font-weight:700>except</span> ValidationError <span style=font-weight:700>as</span> e:
    <span style=font-weight:700>print</span>(e.json())
</code></pre></div><h2 id=what-it-wasnt-designed-to-do>What it wasn&rsquo;t designed to do?</h2><p>From the get-go, Guido clearly stated that type hints are not meant to be used for the following use cases (of course
that does not mean that people do not have libraries/tools outside which do just that - open source power for the win!):</p><h3 id=1-no-runtime-type-inference>1. No runtime type inference</h3><p>The runtime interpreter (CPython) does not try to deduce type information at runtime, and perhaps validate arguments
passed around based on that.</p><h3 id=2-no-performance-tuning>2. No performance tuning</h3><p>The runtime interpreter (CPython) does not use the type information to optimise the generated bytecode for either
security or performance. When executing a Python script type hints are treated just like comments; the interpreter
discards it.</p><p>The key takeaway should be that type hints are designed to improve developer experience, not to influence how your
script evaluates. It creates happy developers, not faster code!</p><p><img src=/content/images/2018/05/happy_programmer.jpeg alt=happy_programmer></p><h1 id=what-kind-of-type-system>What kind of type system?</h1><p>Python has gradual type hinting; meaning that whenever for a given function or variable the type hint is not specified
we assume that it can have any type (that is it remains a dynamically typed section). Use this to gradually make your
code base type-aware, one function or variable at a time. It is possible to type hint:</p><ul><li>function arguments,</li><li>function return values,</li><li>variables.</li></ul><p><em>Remember only type hinted code are type checked!</em> When you run the linter (e.g. mypy) on a type hinted code you&rsquo;ll get
errors if there are type miss-matches:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-style:italic># tests/test_magic_field.py</span>
f = MagicField(name=1, MagicType.DEFAULT)
f.names()
</code></pre></div><p>This code will generate the following output:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bernat@uvm ~/python-magic (master●)$ mypy --ignore-missing-imports tests/test_magic_field.py
tests/test_magic_field.py:21: error: Argument 1 to <span style=font-style:italic>&#34;MagicField&#34;</span> has incompatible type <span style=font-style:italic>&#34;int&#34;</span>;
    expected <span style=font-style:italic>&#34;Union[str, bytes]&#34;</span>
tests/test_magic_field.py:22: error: <span style=font-style:italic>&#34;MagicField&#34;</span> has no attribute <span style=font-style:italic>&#34;names&#34;</span>; maybe <span style=font-style:italic>&#34;name&#34;</span> or <span style=font-style:italic>&#34;_name&#34;</span>?
</code></pre></div><p>Note we can detect both type incompatibility for the argument passed in, and accesses to inexistent attributes on
objects. The later even suggests valid options available, making it easy to notice and fix typos.</p><h2 id=how-to-add-it>How to add it</h2><p>Once you decide to add type hints, you&rsquo;ll come to realise that you can add it in more than one ways to the code base.
Let&rsquo;s see what your options are.</p><h3 id=1-type-annotations>1. Type annotations</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> __init__() -&gt; None:
         self.elements : List[int] = []

   <span style=font-weight:700>def</span> add(element: int) -&gt; None:
         self.elements.append(element)
</code></pre></div><p><em>Type annotations</em> is the straightforward way and is the one you&rsquo;ll find mostly mentioned on the
<a href=https://docs.python.org/3/library/typing.html>typing</a> documentation. It uses function annotations added to language
via <a href=https://www.python.org/dev/peps/pep-3107/>PEP-3107</a> (Python <code>3.0+</code>) and variable annotations via
<a href=https://www.python.org/dev/peps/pep-0526/>PEP-526</a> (Python <code>3.6+</code>). These allow you to use the <code>:</code> syntax to attach
information to variables and function arguments. The <code>-></code> operator is used to attach information to the return value of
a function/method.</p><p>The <strong>upside</strong> of this method is that:</p><ul><li>It is the canonical way of doing this, which means is the cleanest out of them all.</li><li>Because the type information is attached right alongside the code means you&rsquo;ll have packaged this data out of the box.</li></ul><p>The <strong>downside</strong> of it is that:</p><ul><li>It isn&rsquo;t backwards compatible. You need Python <code>3.6</code> at least to use it.</li><li>It also forces you to import <strong>all</strong> of your type dependencies, even though they are not used at runtime at all.</li><li>In the type hints, you can have compound types, for example <code>List[int]</code>. To construct these complex types the
interpreter does need to do some operations when first loading this file.</li></ul><p>The last two point contradicts the initial goal of the type system we enlisted before: that is to handle all type
information basically as a comment during runtime. To resolve some of this contradiction <code>Python 3.7</code> introduces
<a href=https://www.python.org/dev/peps/pep-0563/>PEP-563 ~ postponed evaluation of annotations</a>. Once you add the import of:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>__future__</span> <span style=font-weight:700>import</span> annotations
</code></pre></div><p>The interpreter will no longer construct these compound types. Once the interpreter parses the scripts syntax tree, it
identifies type hints and bypasses evaluating it, keeping it as raw strings. This mechanism allows for type hint
interpretation to happen where they need to: by the linter when it runs type checks. Once the mythical <code>Python 4</code> comes
to life, this mechanism shall be the default behaviour.</p><h3 id=2-type-comments>2. Type comments</h3><p>When the annotation syntax is not available one can use the type comments:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> __init__():
         <span style=font-style:italic># type: () -&gt; None</span>
         self.elements = []  <span style=font-style:italic># type: List[int]</span>

   <span style=font-weight:700>def</span> add(element):
         <span style=font-style:italic># type: (List[int]) -&gt; None</span>
         self.elements.append(element)
</code></pre></div><p>Going down this path, we do get some benefits:</p><ul><li>Type comments work under any Python version. Although the typing library has been added to the standard library with
Python <code>3.5+</code> it is available as PyPi package for Python <code>2.7+</code>. Moreover, because Python comments is a valid language
feature under virtually any Python code, this allows you to type hint any code base at or above Python <code>2.7</code>. There
are a few requirements: the type hint comment <strong>must</strong> be on the same or the next line where the function/variable
definition is. It also starts with the <code>type:</code> constant.</li><li>This solution also has packaging solved because comments are rarely stripped of your code once you stripped it.
Packaging type hint information with your source code allows people using your library to use your type hint information
to improve their developer experience.</li></ul><p>But we also generate some new problems:</p><ul><li>The downside is that although the type information is close to the arguments, it&rsquo;s not right beside it; making the
code a bit messier than otherwise would be. It also must be in a single line which can cause issues if you have a long
type hint expression and your code base enforces line length limits.</li><li>Another problem is that now the type hint information competes with other tools using these types of comment markers
(e.g. suppressing other linter tools errors).</li><li>Besides forcing you to import all of your type information, this leaves you in an even more precarious place. Now the
imported types are only used in the code, which leaves most linter tools to believe all those imports are unused. Were
you to allow them to remove it does break your type linter. Note <code>pylint</code> fixed this by moving its AST parser to a
<a href=https://github.com/PyCQA/pylint/issues/1063>typed-ast parser</a>, and is going to be released with version 2 just after
Python <code>3.7</code> comes out.</li></ul><p>To avoid having long lines of code as type hint, it&rsquo;s possible to type hint arguments one by one via type comments, and
then put in the line after only the return type annotation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> add(element <span style=font-style:italic># type: List[int]</span>
       ):
    <span style=font-style:italic># type: (...) -&gt; None</span>
    self.elements.append(element)
</code></pre></div><p>Let&rsquo;s have a quick use look at how type comments can make your code messier. Below is a code snippet that swaps out two
properties values inside a class. Fairly trivial:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@contextmanager
<span style=font-weight:700>def</span> swap_in_state(state, config, overrides):
    old_config, old_overrides = state.config, state.overrides
    state.config, state.overrides = config, overrides
    <span style=font-weight:700>yield</span> old_config, old_overrides
    state.config, state.overrides = old_config, old_overrides
</code></pre></div><p>First, you must add type hints. Because the type hint would be long winded you attach type hint argument by argument:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@contextmanager
<span style=font-weight:700>def</span> swap_in_state(state,  <span style=font-style:italic># type: State</span>
                  config,  <span style=font-style:italic># type: HasGetSetMutable</span>
                  overrides  <span style=font-style:italic># type: Optional[HasGetSetMutable]</span>
                 ):
<span style=font-style:italic># type: (...) -&gt; Generator[Tuple[HasGetSetMutable, Optional[HasGetSetMutable]], None, None]</span>
    old_config, old_overrides = state.config, state.overrides
    state.config, state.overrides = config, overrides
    <span style=font-weight:700>yield</span> old_config, old_overrides
    state.config, state.overrides = old_config, old_overrides
</code></pre></div><p>However, wait you need to import your types used:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> Generator, Tuple, Optional, Dict, Union, List
<span style=font-weight:700>from</span> <span style=font-weight:700>magic</span> <span style=font-weight:700>import</span> RunSate

HasGetSetMutable = Union[Dict, List]

@contextmanager
<span style=font-weight:700>def</span> swap_in_state(state,  <span style=font-style:italic># type: State</span>
                  config,  <span style=font-style:italic># type: HasGetSetMutable</span>
                  overrides  <span style=font-style:italic># type: Optional[HasGetSetMutable]</span>
                  ):
    <span style=font-style:italic># type: (...) -&gt; Generator[Tuple[HasGetSetMutable, Optional[HasGetSetMutable]], None, None]</span>
    old_config, old_overrides = state.config, state.overrides
    state.config, state.overrides = config, overrides
    <span style=font-weight:700>yield</span> old_config, old_overrides
    state.config, state.overrides = old_config, old_overrides
</code></pre></div><p>Now formatting like this the code causes some false positives in the static linter (e.g. pylint here) so you add a few
suppress comments for this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> Generator, Tuple, Optional, Dict, List
<span style=font-weight:700>from</span> <span style=font-weight:700>magic</span> <span style=font-weight:700>import</span> RunSate

HasGetSetMutable = Union[Dict, List]  <span style=font-style:italic># pylint: disable=invalid-name</span>

@contextmanager
<span style=font-weight:700>def</span> swap_in_state(state,  <span style=font-style:italic># type: State</span>
                   config,  <span style=font-style:italic># type: HasGetSetMutable</span>
                   overrides  <span style=font-style:italic># type: Optional[HasGetSetMutable]</span>
                   ):  <span style=font-style:italic># pylint: disable=bad-continuation</span>
    <span style=font-style:italic># type: (...) -&gt; Generator[Tuple[HasGetSetMutable, Optional[HasGetSetMutable]], None, None]</span>
    old_config, old_overrides = state.config, state.overrides
    state.config, state.overrides = config, overrides
    <span style=font-weight:700>yield</span> old_config, old_overrides
    state.config, state.overrides = old_config, old_overrides
</code></pre></div><p>Now you&rsquo;re done. Nevertheless, you made your six lines of code sixteen lines long. Yay, more code to maintain!
Increasing your code base only sounds good if you&rsquo;re getting paid by the number line of code written and your manager is
complaining you&rsquo;re not performing well enough.</p><h3 id=3-interface-stub-files>3. Interface stub files</h3><p>This option allows you to keep your code as it is:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
  <span style=font-weight:700>def</span> __init__() -&gt; None:
      self.elements = []

  <span style=font-weight:700>def</span> add(element):
      self.elements.append(element)
</code></pre></div><p>and instead add another file with <code>pyi</code> extension right beside it:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-style:italic># a.pyi alongside a.py</span>
<span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
  elements = ... <span style=font-style:italic># type: List[int]</span>
  <span style=font-weight:700>def</span> __init__() -&gt; None: ...
  <span style=font-weight:700>def</span> add(element: int) -&gt; None: ...
</code></pre></div><p>Interface files are not a new thing, C/C++ had it for decades now. Because Python is an interpreted language it does not
need it usually, however as every problem in computer science can be solved by adding a new level of indirection, we can
add it to store the type information.</p><p>The upside of this is that:</p><ul><li>You don&rsquo;t need to modify the source code, works under any Python version as the interpreter never touches these.</li><li>Inside the stub files, you can use the latest syntax (e.g. type annotations) because these are never looked at during
execution of your application.</li><li>Because you do not touch your source code this means by adding type hints you cannot introduce bugs, neither can what
you add conflict with other linter tools.</li><li>It is a well-tested design, the <a href=https://github.com/python/typeshed>typeshed</a> project uses it to type hint the entire
standard library, plus some other popular libraries such as requests, yaml, dateutil and
<a href=https://github.com/python/typeshed/tree/master/third_party>so on</a>.</li><li>Can be used to provide type information for source code that you do not own or you cannot change it easily.</li></ul><p>Now there are also some hefty penalties to pay:</p><ul><li>You just duplicated your code base, as every function now has two definitions (note you don&rsquo;t need to replicate your body or default arguments, the <code>...</code> - ellipsis - is used as a placeholder for these).</li><li>Now you have some extra files that need to be packaged and shipped with your code.</li><li>It&rsquo;s not possible to annotate contents inside functions (this means both methods inside methods, and local variables).</li><li>There is no check that your implementation file matches the signature of your stub (furthermore IDEs always use foremost the stub definition).</li><li>However, the heaviest penalty is that you cannot type check the code you&rsquo;re type hinting via a stub. Stub file type hints were designed to be used to type check code that uses the library. But not too type check the code base itself what your type hinting.</li></ul><p>The last two drawback makes it especially hard to check that the type hinted code base via a stub file is in sync or
not. In this current form type stubs are a way to provide type hints to your users, but not for yourself, and are
especially hard to maintain. To fix these, I&rsquo;ve taken up the task of merging stub files with source files inside mypy;
in theory, would fix both problems - you can follow on its progress under
<a href=https://github.com/python/mypy/issues/5028>python/mypy ~ issue 5208</a>.</p><h3 id=4-docstrings>4. Docstrings</h3><p>It is possible to add type information into docstrings too. Even though this is not part of the type hint framework
designed for Python, it is supported by most mainstream IDEs. They are mostly the legacy way of doing this.</p><p>On the plus side:</p><ul><li>Works under any Python version, it was defined back in <a href=https://www.python.org/dev/peps/pep-0257/>PEP-257</a>.</li><li>Does not clash with other linter tools, as most of these do not check the docstrings, but usually resume on just
inspecting the other code sections instead.</li></ul><p>However, it has serious flaws in the form of:</p><ul><li>There is no standard way to specify complex type hints (for example either <code>int</code> or <code>bool</code>). PyCharm has
<a href=https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html#legacy>its proprietary way</a> but Sphinx, for
example, uses a different method. T- Docstring types does not clash with other linter tools.</li><li>Requires changing the documentation, and is hard to keep accurate/up to date as there is no tool to check it&rsquo;s
validity.</li><li>Docstring types do not play well with type hinted code. If both type annotations and docstrings are specified which
takes precedence over which?</li></ul><h2 id=what-to-add>What to add?</h2><p><img src=/content/images/2018/05/deep_dive.jpg alt=deep_dive></p><p>Let&rsquo;s dive into the specifics though. For an exhaustive list of what type information you can add, please see the
<a href=https://docs.python.org/3/library/typing.html>official documentation</a>. Here I&rsquo;ll do a quick 3-minute overview for you
to get the idea of it. There are two types of type categories: nominal types and duck types (protocols).</p><h3 id=1-nominal-type>1. Nominal type</h3><p>Nominal types are types that have a name to it within the Python interpreter. For example all builtin types (<code>int</code>,
<code>bolean</code>, <code>float</code>, <code>type</code>, <code>object</code> etc). Then we have the generic types which mostly manifest in form of the
containers:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>t : Tuple[int, float] = 0, 1.2
d : Dict[str, int] = {<span style=font-style:italic>&#34;a&#34;</span>: 1, <span style=font-style:italic>&#34;b&#34;</span>: 2}
d : MutableMapping[str, int] = {<span style=font-style:italic>&#34;a&#34;</span>: 1, <span style=font-style:italic>&#34;b&#34;</span>: 2}
l : List[int] = [1, 2, 3]
i : Iterable[Text] = [ <span style=font-style:italic>u</span><span style=font-style:italic>&#39;1&#39;</span>, <span style=font-style:italic>u</span><span style=font-style:italic>&#39;2&#39;</span>, <span style=font-style:italic>u</span><span style=font-style:italic>&#39;3&#39;</span>]
</code></pre></div><p>For compound types, it can become cumbersome to keep writing it again and again, so the system allows you to alias
types, via:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>OptFList = Optional[List[float]]
</code></pre></div><p>One can even elevate builtin types to represent their own type, which can be useful to avoid errors where for example
you pass in two arguments with the same type in the wrong order to a function:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>UserId = NewType(<span style=font-style:italic>&#39;UserId&#39;</span>, int)
user_id = UserId(524313)
count = 1
call_with_user_id_n_times(user_id, count)
</code></pre></div><p>For <code>namedtuple</code> you can attach your type information directly (note the strong resemblance to a
<a href=https://www.python.org/dev/peps/pep-0557/>data class</a> from Python <code>3.7+</code> or the great
<a href=https://github.com/python-attrs/attrs>attrs library</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>class</span> <span style=font-weight:700>Employee</span>(NamedTuple):
     name: str
     id: int
</code></pre></div><p>You have the composing types of <em>one of</em> and <em>optional of</em>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>Union[None, int, str] <span style=font-style:italic># one of</span>
Optional[float] <span style=font-style:italic># either None or float</span>
</code></pre></div><p>You can even type hint your callback functions:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-style:italic># syntax is Callable[[Arg1Type, Arg2Type], ReturnType]</span>
<span style=font-weight:700>def</span> feeder(get_next_item: Callable[[], str]) -&gt; None:
</code></pre></div><p>One can define it&rsquo;s own generic containers by using the <code>TypeVar</code> construction:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>T = TypeVar(<span style=font-style:italic>&#39;T&#39;</span>)
<span style=font-weight:700>class</span> <span style=font-weight:700>Magic</span>(Generic[T]):
      <span style=font-weight:700>def</span> __init__(self, value: T) -&gt; None:
         self.value : T = value

 <span style=font-weight:700>def</span> square_values(vars: Iterable[Magic[int]]) -&gt; None:
     v.value = v.value * v.value
</code></pre></div><p>Finally, disable type checking wherever it&rsquo;s not needed by using the <code>Any</code> type hint:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> foo(item: Any) -&gt; int:
     item.bar()
</code></pre></div><h3 id=2-duck-types---protocols>2. Duck types - protocols</h3><p>In this case instead of having an actual type one can be more Pythonic, and go with the theorem that if it quacks like a
duck, and acts like a duck, then most definitely for all intended purposes it is a duck. In this case, you define what
operations and attributes you expect on objects instead of explicitly stating their types. The grounds of this were laid
down in <a href=https://www.python.org/dev/peps/pep-0544/>PEP-544 ~ Protocols</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>KEY = TypeVar(<span style=font-style:italic>&#39;KEY&#39;</span>, contravariant=true)

<span style=font-style:italic># this is a protocol having a generic type as argument</span>
<span style=font-style:italic># it has a class variable of type var, and a getter with the same key type</span>
<span style=font-weight:700>class</span> <span style=font-weight:700>MagicGetter</span>(Protocol[KEY], Sized):
    var : KEY
    <span style=font-weight:700>def</span> __getitem__(self, item: KEY) -&gt; int: ...

<span style=font-weight:700>def</span> func_int(param: MagicGetter[int]) -&gt; int:
    <span style=font-weight:700>return</span> param[<span style=font-style:italic>&#39;a&#39;</span>] * 2

<span style=font-weight:700>def</span> func_str(param: MagicGetter[str]) -&gt; str:
    <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;{}&#39;</span>.format(param[<span style=font-style:italic>&#39;a&#39;</span>])
</code></pre></div><h1 id=gotchas>Gotchas</h1><p>Once you start adding type hints to a code base watch out that sometimes you may experience some oddities. During this
moments you might have the *what the hell** expression of the following seal:
<img src=/content/images/2018/05/gotcha.jpg alt=gotcha></p><p>In this section, I&rsquo;ll try to present a few of these to give you a heads up on what kind of oddities you may run into
while adding type information to your code base.</p><h3 id=1-str-difference-in-between-python-23>1. str difference in between Python 2/3</h3><p>Here&rsquo;s a quick implementation of the <code>repr</code> dunder method for a class:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>__future__</span> <span style=font-weight:700>import</span> unicode_literals

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> __repr__(self) -&gt; str:
        <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;A({})&#39;</span>.format(self.full_name)
</code></pre></div><p>This code has a bug in it. While this is correct under Python 3, it is not under Python 2 (because Python 2 expects to
return <code>bytes</code> from <code>repr</code>, however, the <code>unicode_literals</code> import makes the returned value of type <code>unicode</code>). Having
the from future import in place means it&rsquo;s not possible to write a repr that satisfies the type requirements for both
Python 2 and 3. You need to add runtime logic to do the right thing:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>__future__</span> <span style=font-weight:700>import</span> unicode_literals

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> __repr__(self) -&gt; str:
        res = <span style=font-style:italic>&#39;A({})&#39;</span>.format(self.full_name)
        <span style=font-weight:700>if</span> sys.version_info &gt; (3, 0):
            <span style=font-style:italic># noinspection PyTypeChecker</span>
            <span style=font-weight:700>return</span> res
        <span style=font-style:italic># noinspection PyTypeChecker</span>
        <span style=font-weight:700>return</span> res.encode(<span style=font-style:italic>&#39;utf-8&#39;</span>)
</code></pre></div><p>Now to fight the IDE to accept this form you need to add a few linter comments, which makes this code ever so
complicated to read. More importantly, now you have an extra runtime check forced to your type checker.</p><h3 id=2-multiple-return-types>2. Multiple return types</h3><p>Imagine you want to write a function that multiplies either a string or an int by two. The first take on this would be:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> magic(i: Union[str, int]) -&gt; Union[str, int]:
    <span style=font-weight:700>return</span> i * 2
</code></pre></div><p>Your input is either <code>str</code> or <code>int</code>, and your return value accordingly is also either <code>str</code> or <code>int</code>. However, if you do
it like so, you&rsquo;re telling to the type hint that it really can be either of for both types of inputs. Therefore on the
call side, you need to assert the type your calling with:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>def</span> other_func() -&gt; int:
    result = magic(2)
    <span style=font-weight:700>assert</span> isinstance(result, int)
    <span style=font-weight:700>return</span> result
</code></pre></div><p>This inconvenience may determine some people to avoid the call side hassle by making the return value <code>Any</code>. However,
there&rsquo;s a better solution. The type hint system allows you to define overloads. Overloads express that for a given input
type only a given output type is returned. So in this case:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> overload

@overload
<span style=font-weight:700>def</span> magic(i: int) -&gt; int:
    <span style=font-weight:700>pass</span>

@overload
<span style=font-weight:700>def</span> magic(i: str) -&gt; str:
    <span style=font-weight:700>pass</span>

<span style=font-weight:700>def</span> magic(i: Union[int, str]) -&gt; Union[int, str]:
    <span style=font-weight:700>return</span> i * 2

<span style=font-weight:700>def</span> other_func() -&gt; int:
    result = magic(2)
    <span style=font-weight:700>return</span> result
</code></pre></div><p>There is a downside to this though. Now your static linter tool is complaining that you&rsquo;re redefining functions with the
same name; this is a false positive so add the static linter disable comment mark
(<code># pylint: disable=function-redefined</code> ).</p><h3 id=3-type-lookup>3. Type lookup</h3><p>Imagine you have a class that allows representing the contained data as multiple types, or that has fields of the
different type. You want the user to have a quick and easy way to refer to them, so you add a function, having a
built-in types name:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> float(self):
            <span style=font-style:italic># type: () -&gt; float</span>
           <span style=font-weight:700>return</span> 1.0
</code></pre></div><p>Once you run the linter you&rsquo;ll see:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>test.py:3: error: Invalid type <span style=font-style:italic>&#34;test.A.float&#34;</span>
</code></pre></div><p>One might ask at this point, what the hell? I&rsquo;ve defined the return value as <code>float</code> not as <code>test.A.float</code>. The reason
for this obscure error is that the type hinter resolves types by evaluating each scope outbound from the definition
location. Once it finds a name match, it stops. The first level where it looks is within <code>class A</code> where it finds a
<code>float</code> (a function that is) and substitutes that float in.</p><p>Now the solution to not run into this issue is to explicitly define that we don&rsquo;t just want any <code>float</code>, but that we
want the <code>builtin.float</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>if</span> typing.TYPE_CHECKING:
    <span style=font-weight:700>import</span> <span style=font-weight:700>builtins</span>

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(object):
    <span style=font-weight:700>def</span> float(self):
            <span style=font-style:italic># type: () -&gt; builtins.float</span>
           <span style=font-weight:700>return</span> 1.0
</code></pre></div><p>Note that to do this you also need to import <code>builtins</code>, and to avoid this causing issues at runtime, you can guard it
with the <code>typing.TYPE_CHECKING</code> flag which is true only during the type linter evaluation, always false otherwise.</p><h3 id=4-contravariant-argument>4. Contravariant argument</h3><p>Examine the following use case. You define an abstract base class that contains common operations. Then you have
specific classes which handle one type and one type only. You control the creation of the classes which ensures the
correct type is passed, and the base is abstract, so this seems an agreeable design:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>abc</span> <span style=font-weight:700>import</span> ABCMeta, abstractmethod
<span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> Union

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(metaclass=ABCMeta):
    @abstractmethod
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (Union[int, str]) -&gt; str</span>
        <span style=font-weight:700>raise</span> <span style=font-weight:700>NotImplementedError</span>

<span style=font-weight:700>class</span> <span style=font-weight:700>B</span>(A):
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (int) -&gt; str</span>
        <span style=font-weight:700>return</span> str(key)

<span style=font-weight:700>class</span> <span style=font-weight:700>C</span>(A):
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (str) -&gt; str</span>
        <span style=font-weight:700>return</span> key
</code></pre></div><p>However, once you run a type linter check on this you&rsquo;ll find:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>test.py:12: error: Argument 1 of <span style=font-style:italic>&#34;func&#34;</span> incompatible with supertype <span style=font-style:italic>&#34;A&#34;</span>
test.py:17: error: Argument 1 of <span style=font-style:italic>&#34;func&#34;</span> incompatible with supertype <span style=font-style:italic>&#34;A&#34;</span>
</code></pre></div><p>The reason for this is that arguments to classes are contravariant. This translates in on scientific terms in your
derived class you <strong>must</strong> handle all types from your parents. However, you may add additional types too. That is even
in the function arguments you can only extend what you cover, but not to constrain it in any way:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>abc</span> <span style=font-weight:700>import</span> ABCMeta, abstractmethod
<span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> Union

<span style=font-weight:700>class</span> <span style=font-weight:700>A</span>(metaclass=ABCMeta):
    @abstractmethod
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (Union[int, str]) -&gt; str</span>
        <span style=font-weight:700>raise</span> <span style=font-weight:700>NotImplementedError</span>

<span style=font-weight:700>class</span> <span style=font-weight:700>B</span>(A):
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (Union[int, str, bool]) -&gt; str</span>
        <span style=font-weight:700>return</span> str(key)

<span style=font-weight:700>class</span> <span style=font-weight:700>C</span>(A):
    <span style=font-weight:700>def</span> func(self, key):  <span style=font-style:italic># type: (Union[int, str, List]) -&gt; str</span>
        <span style=font-weight:700>return</span> key
</code></pre></div><h3 id=5-compatibility>5. Compatibility</h3><p>See if you can spot the error in the following code snippet:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>class</span> <span style=font-weight:700>A</span>:
    @classmethod
    <span style=font-weight:700>def</span> magic(cls, a: int) -&gt; <span style=font-style:italic>&#39;A&#39;</span>:
        <span style=font-weight:700>return</span> cls()

<span style=font-weight:700>class</span> <span style=font-weight:700>B</span>(A):
    @classmethod
    <span style=font-weight:700>def</span> magic(cls, a: int, b: bool) -&gt; <span style=font-style:italic>&#39;B&#39;</span>:
        <span style=font-weight:700>return</span> cls()
</code></pre></div><p>If you did not manage yet consider what will happen if you write the following script:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List, Type

elements : List[Type[A]] = [A, B]
<span style=font-weight:700>print</span>( [e.magic(1) <span style=font-weight:700>for</span> e <span style=font-weight:700>in</span> elements])
</code></pre></div><p>Were you to try to run it this would fail with the following runtime error:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=font-weight:700>print</span>( [e.magic(1) <span style=font-weight:700>for</span> e <span style=font-weight:700>in</span> elements])
<span style=font-weight:700>TypeError</span>: magic() missing 1 required positional argument: <span style=font-style:italic>&#39;b&#39;</span>
</code></pre></div><p>The reason being that <code>B</code> is a subtype of <code>A</code>. Therefore it can go into a container of <code>A</code> types (because it extends it,
so it can do more than <code>A</code>). However the class method definition for <code>B</code> breaks this contract, it can no longer call
magic with just one argument. Moreover, the type linter would fail to point out just this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>test.py:9: error: Signature of <span style=font-style:italic>&#34;magic&#34;</span> incompatible with supertype <span style=font-style:italic>&#34;A&#34;</span>
</code></pre></div><p>A quick and easy fix for this is to make sure <code>B.magic</code> does work with one argument by making the second optional for
example. Now take what we learned to take a look at the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>class</span> <span style=font-weight:700>A</span>:
    <span style=font-weight:700>def</span> __init__(self, a: int) -&gt; None:
        <span style=font-weight:700>pass</span>

<span style=font-weight:700>class</span> <span style=font-weight:700>B</span>(A):
    <span style=font-weight:700>def</span> __init__(self, a: int, b: bool) -&gt; None:
        super().__init__(a)
</code></pre></div><p>What do you think will happen here? Note we moved class methods into constructors, and made no other change, so our
script also needs just a slight modification:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List, Type

elements : List[Type[A]]= [A, B]
<span style=font-weight:700>print</span>( [e(1) <span style=font-weight:700>for</span> e <span style=font-weight:700>in</span> elements])
</code></pre></div><p>Here&rsquo;s the runtime error, being mostly the same, just now complaining about <code>__init__</code> instead of <code>magic</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>    print( [e(1) <span style=font-weight:700>for</span> e in elements])
TypeError: __init__() missing 1 required positional argument: <span style=font-style:italic>&#39;b&#39;</span>
</code></pre></div><p>So what do you think mypy will say? Were you to run it you&rsquo;ll find that mypy chooses to stay silent. Yes, it will mark
this as correct, even though at runtime it fails. The mypy creators said that they found <em>too common of type miss-match
to prohibit incompatible <code>__init__</code> and <code>__new__</code></em>.</p><h2 id=when-you-hit-the-wall>When you hit the wall</h2><p>So, in conclusion, watch out, type hints sometimes cause strange warnings, which brings out the following feelings
summarised in a tweet:</p><p><img src=/content/images/2018/05/david.png alt=david></p><p>Remember you have some tools at hand that help you discover, understand and perhaps handle these edge cases:</p><ul><li>use <code>reveal_type</code> to see inferred type<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>a = [4]
reveal_type(a)         <span style=font-style:italic># -&gt; error: Revealed type is &#39;builtins.list[builtins.int*]&#39;</span>
</code></pre></div></li><li>use <code>cast</code> to force a given type:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700>from</span> <span style=font-weight:700>typing</span> <span style=font-weight:700>import</span> List, cast
a = [4]
b = cast(List[int], a) <span style=font-style:italic># passes fine</span>
c = cast(List[str], a) <span style=font-style:italic># type: List[str] # passes fine (no runtime check)</span>
reveal_type(c)         <span style=font-style:italic># -&gt; error: Revealed type is &#39;builtins.list[builtins.str]&#39;</span>
</code></pre></div></li><li>use the type ignore marker to disable an error in a line:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>x = confusing_function() <span style=font-style:italic># type: ignore # see mypy/issues/1167</span>
</code></pre></div></li><li>ask the community; expose a minimal reproducible version of the problem under the
<a href=https://gitter.im/python/typing>python/typing</a> Gitter chat.</li></ul><h1 id=tools>Tools</h1><p>Here&rsquo;s a non exhaustive list of tools built around the type hint system.</p><h2 id=type-checkers>type checkers</h2><p>Use these tools to check against type safety inside your library or application:</p><ol><li><a href=http://mypy-lang.org/>mypy - Python</a> (the reference type linting tool)</li><li><a href=https://github.com/facebook/pyre-check>pyre - Facebook</a> - Python 3 only, but faster than mypy. An interesting use
case of this is the ability to do taint/security code analysis with it - see
<a href="https://www.youtube.com/watch?v=hWV8t494N88">Pieter Hooimeijer - Types, Deeper Static Analysis, and you</a>.</li><li><a href=https://github.com/google/pytype>pytype - Google</a>.</li></ol><h2 id=type-annotation-generators>type annotation generators</h2><p>When you want to add type annotations to an existing code base use these to automate the boring part:</p><ol><li><code>mypy stubgen</code> command line (<a href=https://github.com/python/mypy/blob/master/mypy/stubgen.py>see</a>)</li><li><a href=https://github.com/dropbox/pyannotate>pyannotate - Dropbox</a> - use your tests to generate type information.</li><li><a href=https://github.com/Instagram/MonkeyType>monkeytype - Instagram</a>. Fun fact: Instagram actualy uses to run it in
their production system: it&rsquo;s triggered once for every million cal (makes the code run five times slower, but once
every million calls makes it not that noticeable).</li></ol><h2 id=runtime-code-evaluator>runtime code evaluator</h2><p>Use these tools to check at runtime if the input arguments to your function/method are of correct type or not:</p><ol><li><a href=https://github.com/samuelcolvin/pydantic>pydantic</a></li><li><a href=https://github.com/RussBaz/enforce>enforce</a></li><li><a href=https://github.com/Stewori/pytypes>pytypes</a></li></ol><h2 id=documentation-enrichment---merge-docstrings-and-type-hints>Documentation enrichment - merge docstrings and type hints</h2><p>In the first part of this blog article, we mentioned that historically people have already stored type information
inside docstrings. The reason for this is that your type data is part of your contract, you do want to have type
information for your library inside the documentation. So the question remains given that you did not choose to use
docstrings as the primary type information storage system, how can you still have them in the docstrings for your
documentation?</p><p>The answer varies depending on the tool you&rsquo;re using to generate that documentation. However, I&rsquo;m going to present here
an option by using the most popular tool and format in Python: Sphinx and HTML.</p><p>Having type information explicitly stated in both the type hints and the docstring is the sure way of eventually having
conflicts in between them. You can count on someone at some point is going to update in one place but not in the other.
Therefore let&rsquo;s strip all type data from the docstring and have it only as type hints. Now, all we need to do is at
documentation build time fetch it from the type hints and insert it into the documentation.</p><p>In Sphinx, you can achieve this by having a plugin. The most popular already made version of this is
<a href=https://github.com/agronholm/sphinx-autodoc-typehints>agronholm/sphinx-autodoc-typehints</a>. This tool does two things:</p><ul><li>first, for each function/variable to be documented, it fetches the type hint information;</li><li>then, it transforms the Python types into a docstring representation (this involves recursively unwrapping all the
nested type classes, and replacing the type with its string representation);</li><li>finally, appending to the correct parameter into the docstring.</li></ul><p>For example <code>Any</code> maps to <code>py:data:`~typing.Any` </code>. Things can get even more complicated for compound types such as
<code>Mapping[str, bool]</code> needs to be translated for example too
<code>:class:`~typing.Mapping`\\[:class:`str`, :class:`bool`]</code>. Getting the translation here right (e.g. having <code>class</code>
or <code>data</code> namespace) is essential so that the <code>intersphinx</code> plugin will work correctly (a plugin that links types
directly to their respective Python standard library documentation link).</p><p>In order to use it one needs to install it via <code>pip install sphinx-autodoc-types>=2.1.1</code> and then enable in inside the
<code>conf.py</code> file:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-style:italic># conf.py</span>
extensions = [<span style=font-style:italic>&#39;sphinx_autodoc_typehints&#39;</span>]
</code></pre></div><p>That&rsquo;s it all. An example use case of this is <a href=https://github.com/RookieGameDevs/revived>RookieGameDevs/revived</a>
documentation. For example, given the following source code:</p><p><img src=/content/images/2018/05/sphinx_doc_src.PNG alt=sphinx_doc_src></p><p>You can get the following output:</p><p><img src=/content/images/2018/05/sphinx_doc.PNG alt=sphinx_doc></p><h1 id=conclusion>Conclusion</h1><p>So at the end of this long blog post, you may ask: is it worth using type hints, or when should one use them? I think
type hinting is at the end of the day essentially the same as your unit tests, just expressed differently in code. What
they provide is a standard (and re-usable for other goals) way, to test the input and output types of your codebase.</p><p>Therefore, type hints <strong>should be used whenever unit test are worth writing.</strong> This can be even just ten lines of code
if you need to maintain it later. Similarly, you should start adding type hints whenever you start writing unit tests.
The only place when I would not add them is when I don&rsquo;t write unit tests, such REPL lines, or throw away one-time usage
scripts.</p><p>Remember that, similar to unit tests, while it does makes your code base contain an extra number of lines, at the end of
the day all the code you add is code that is automatically checked and enforced to be correct. It acts as a safety net
to ensure that when you change things around later on things keep working, so probably worth paying this extra cost.</p><p><img src=/content/images/2018/05/thats_all_folks.jpg alt=thats_all_folks></p></div><footer></footer></article></section></div><footer class=footer><section class=container><p>Software engineer <a href=https://github.com/bloomberg>at Bloomberg (London)</a>. Maintainer of <a href=https://github.com/gaborbernat/>many FOSS Python packages</a>. Opinions are my own.</p></section></footer></main><script src=/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script></body></html>