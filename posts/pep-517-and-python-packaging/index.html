<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Bernát Gábor"><meta name=description content="pip 19.0 has been released on 22nd January 2019. On the feature list, most notably, it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed confirmed that many people are not familiar with it."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/discover_pug.webp"><meta name=twitter:title content="The state of Python Packaging"><meta name=twitter:description content="pip 19.0 has been released on 22nd January 2019. On the feature list, most notably, it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed confirmed that many people are not familiar with it."><meta property="og:title" content="The state of Python Packaging"><meta property="og:description" content="pip 19.0 has been released on 22nd January 2019. On the feature list, most notably, it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed confirmed that many people are not familiar with it."><meta property="og:type" content="article"><meta property="og:url" content="https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/"><meta property="og:image" content="https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/discover_pug.webp"><meta property="article:published_time" content="2019-02-07T13:40:54+00:00"><meta property="article:modified_time" content="2019-02-07T13:40:54+00:00"><title>The state of Python Packaging · Tech articles by Bernát Gábor</title><link rel=canonical href=https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/bernat-tech/css/coder.min.9626fd4842064ea418d8e4060bddb5686db78f27a22297cd3731f59730faf1e5.css integrity="sha256-lib9SEIGTqQY2OQGC921aG23jyeiIpfNNzH1lzD68eU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/bernat-tech/css/coder-dark.min.dde8a61eb31a32353b4baf3d9113f03c4ea2a8ca9bb736f59ca2d2b2cb664f0b.css integrity="sha256-3eimHrMaMjU7S689kRPwPE6iqMqbtzb1nKLSsstmTws=" crossorigin=anonymous media=screen><link rel=stylesheet href=/bernat-tech/css/custom.css><link rel=icon type=image/png href=/bernat-tech/img/android-chrome-192x192.png sizes=32x32><link rel=icon type=image/png href=/bernat-tech/img/android-chrome-192x192.png sizes=16x16><link rel=apple-touch-icon href=/bernat-tech/img/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=/bernat-tech/img/android-chrome-192x192.png><meta name=generator content="Hugo 0.78.2"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/bernat-tech>Tech articles by Bernát Gábor</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/bernat-tech/posts>Blog</a></li><li class=navigation-item><a class=navigation-link href=/bernat-tech/about>About</a></li><li class=navigation-item><a class=navigation-link href=/bernat-tech/presentations>Presentations</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/>The state of Python Packaging</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2019-02-07T13:40:54Z>February 7, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>9-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/bernat-tech/tags/python/>python</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/packaging/>packaging</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pip/>pip</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/setuptools/>setuptools</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pep517/>pep517</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pep518/>pep518</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/wheel/>wheel</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/sdist/>sdist</a></div></div></header><div><p>pip 19.0 has been released on 22nd January 2019. On the feature list, most notably, it now supports PEP-517, which by
default is turned <strong>on</strong> when that the project has a <code>pyproject.toml</code> at the root folder. The PEP in question has been
created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues
that followed confirmed that many people are not familiar with it. Read on if you want to get a picture of how the
Python packaging ecosystem evolved today and where we hope to see it down the line. We expect that even though the
introduction of the aforementioned python enhancement proposal may cause some discomfort, we will benefit from it in the
long term.</p><p>I joined the Python open-source community around three years ago (though I have used it for more than 8 years). I&rsquo;ve
remarked that the Python packaging has a reputation of a somewhat black box from the early days. There are many unknown
parts, and people mostly get by with just copying other projects, build configurations, and roll with them. On my path
to better understanding this black box and improving it, I&rsquo;ve become the maintainer of both the virtualenv and tox
project, occasionally contributing to both <code>setuptools</code> and <code>pip</code>.</p><p>As I hope to give an exhausting (hopefully still a relatively high level) overview of the subject, I decided to split it
up into three posts. In this first post, I will give a broad overview of how Python packaging works and the type of
packages it has. In a subsequent post, I will present in detail how the installation of packages works and how
PEP-517/518 tries to improve on it. Finally, I dedicate a whole other post to explain some of the painful lessons we
learned while introducing these improvements. A heads up, I will focus mainly on the Python Packaging Authorities
systems (<code>pip</code>, <code>setuptools</code>, so no <code>conda</code> or operating system-specific packagers).</p><figure><img src=sad_pug.webp></figure><h1 id=an-example-project>An example project
<a class=heading-link href=#an-example-project><i class="fa fa-link" aria-hidden=true></i></a></h1><p>To tell this story, I&rsquo;ll need to tell how to distribute python packages; more specifically, explain how to package
installation worked in the past and how we hope it will work in the future. To have a concrete example of what to
demonstrate, let me introduce my excellent example library: <code>pugs</code>. This library reasonably simple: it generates a
single package called <code>pugs</code> containing only a single module called <code>logic</code>. The logic is to generate random quotes, you
guessed right, about <em>pugs</em>. Here&rsquo;s a simple example structure of it viewed as a source tree (also available under
<a href=https://github.com/gaborbernat/pugs>gaborbernat/pugs</a>):</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>pugs-project
├── README.rst
├── setup.cfg
├── setup.py
├── LICENSE.txt
├── src
│   └── pugs
│       ├── __init__.py
│       └── logic.py
├── tests
│   ├── test_init.py
│   └── test_logic.py
├── tox.ini
└── azure-pipelines.yml
</code></pre></div><p>We have four distinct content type here:</p><p>What would it mean for our <code>pugs</code> package to be available on a user machine&rsquo;s interpreter? Ideally, the user should be
able to import it and call functions from it once it starts up the interpreter:</p><ul><li>the business logic code (what&rsquo;s inside the <code>src</code> folder),</li><li>the test code (<code>tests</code> folder and <code>tox.ini</code>),</li><li>the packaging code and metadata (<code>setup.py</code>, <code>setup.cfg</code>, <code>LICENSE.txt</code>, <code>README.rst</code> - note we use nowadays the de
facto standard packaging tool <a href=https://pypi.org/project/setuptools>setuptools</a>),</li><li>files helping with project management and maintenance:<ul><li>continuous-integration (<code>azure-pipelines.yml</code>)</li><li>version control (<code>.git</code>)</li><li>project management (for example, a potential <code>.github</code> folder).</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>Python</span> <span class=mf>3.7</span><span class=o>.</span><span class=mi>2</span> <span class=p>(</span><span class=n>v3</span><span class=o>.</span><span class=mf>7.2</span><span class=p>:</span><span class=mi>9</span><span class=n>a3ffc0492</span><span class=p>,</span> <span class=n>Dec</span> <span class=mi>24</span> <span class=mi>2018</span><span class=p>,</span> <span class=mo>02</span><span class=p>:</span><span class=mi>44</span><span class=p>:</span><span class=mi>43</span><span class=p>)</span>
<span class=p>[</span><span class=n>Clang</span> <span class=mf>6.0</span> <span class=p>(</span><span class=n>clang</span><span class=o>-</span><span class=mf>600.0</span><span class=o>.</span><span class=mi>57</span><span class=p>)]</span> <span class=n>on</span> <span class=n>darwin</span>
<span class=n>Type</span> <span class=s2>&#34;help&#34;</span><span class=p>,</span> <span class=s2>&#34;copyright&#34;</span><span class=p>,</span> <span class=s2>&#34;credits&#34;</span> <span class=ow>or</span> <span class=s2>&#34;license&#34;</span> <span class=k>for</span> <span class=n>more</span> <span class=n>information</span><span class=o>.</span>
<span class=o>&gt;&gt;&gt;</span> <span class=kn>import</span> <span class=nn>pugs</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>pugs</span><span class=o>.</span><span class=n>do_tell</span><span class=p>()</span>
<span class=s2>&#34;An enlightened pug knows how to make the best of whatever he has to work with - A Pug&#39;s Guide to Dating -  Gemma Correll&#34;</span>
</code></pre></div><figure><img src=enlightened_pug.webp></figure><h1 id=python-package-availability>Python package availability
<a class=heading-link href=#python-package-availability><i class="fa fa-link" aria-hidden=true></i></a></h1><p>How does Python knows what&rsquo;s available or not? The short answer is it does not. Not upfront, at least, that is. Instead,
it will try to load and see if it succeeds dynamically. From where does it load it? There are many possible locations,
but in most cases, we are talking about loading it from a folder on the file system. Where is this folder? For a given
module, one can print out the representation of the module to find out:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=kn>import</span> <span class=nn>pugs</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>pugs</span>
<span class=o>&lt;</span><span class=n>module</span> <span class=s1>&#39;pugs&#39;</span> <span class=kn>from</span> <span class=s1>&#39;/Users/bernat/Library/Python/3.7/lib/python/site-packages/pugs/__init__.py&#39;</span><span class=o>&gt;</span>
</code></pre></div><p>The folder under you&rsquo;ll find it depends on:</p><ul><li>the type of the package it is (third-party or built-in/aka part of the standard library)</li><li>if it&rsquo;s globally or just for the current user available (see <a href=https://www.python.org/dev/peps/pep-0370/>PEP-370</a>),</li><li>and if it&rsquo;s a system python or a virtual environment.</li></ul><p>Generally speaking, though, for a given python interpreter, one can find a list of possible directories by printing out
the <code>sys.path</code> variables content, for example, on my macOS:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=kn>import</span> <span class=nn>sys</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>))</span>
<span class=o>/</span><span class=n>Library</span><span class=o>/</span><span class=n>Frameworks</span><span class=o>/</span><span class=n>Python</span><span class=o>.</span><span class=n>framework</span><span class=o>/</span><span class=n>Versions</span><span class=o>/</span><span class=mf>3.7</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>python37</span><span class=o>.</span><span class=n>zip</span>
<span class=o>/</span><span class=n>Library</span><span class=o>/</span><span class=n>Frameworks</span><span class=o>/</span><span class=n>Python</span><span class=o>.</span><span class=n>framework</span><span class=o>/</span><span class=n>Versions</span><span class=o>/</span><span class=mf>3.7</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>python3</span><span class=o>.</span><span class=mi>7</span>
<span class=o>/</span><span class=n>Library</span><span class=o>/</span><span class=n>Frameworks</span><span class=o>/</span><span class=n>Python</span><span class=o>.</span><span class=n>framework</span><span class=o>/</span><span class=n>Versions</span><span class=o>/</span><span class=mf>3.7</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>python3</span><span class=o>.</span><span class=mi>7</span><span class=o>/</span><span class=n>lib</span><span class=o>-</span><span class=n>dynload</span>
<span class=o>/</span><span class=n>Users</span><span class=o>/</span><span class=n>bernat</span><span class=o>/</span><span class=n>Library</span><span class=o>/</span><span class=n>Python</span><span class=o>/</span><span class=mf>3.7</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>python</span><span class=o>/</span><span class=n>site</span><span class=o>-</span><span class=n>packages</span>
<span class=o>/</span><span class=n>Library</span><span class=o>/</span><span class=n>Frameworks</span><span class=o>/</span><span class=n>Python</span><span class=o>.</span><span class=n>framework</span><span class=o>/</span><span class=n>Versions</span><span class=o>/</span><span class=mf>3.7</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>python3</span><span class=o>.</span><span class=mi>7</span><span class=o>/</span><span class=n>site</span><span class=o>-</span><span class=n>packages</span>
</code></pre></div><p>For third-party packages, it&rsquo;s going to be some <code>site-packages</code> folder. Note in the above example how there&rsquo;s a
system-wide and a user-specific instance of this. How do packages end up inside this folder? It must be put there by
some installer.</p><p>The following diagram displays how most of the time things go:</p><figure><img src=diagram.webp></figure><ol><li>The developer writes some python code inside a folder (referred to as the source tree).</li><li>Some tool (such as <code>setuptools</code>) then takes the source tree and packages it up for redistribution.</li><li>The generated package is uploaded via another tool (twine) to a central repository (usually
<a href=https://pypi.org>https://pypi.org</a>) the end-user machine has access to.</li><li>The end-user machine uses some installer that discovers, downloads, and installs the package in question. The
installation operation boils down by creating the correct directory structure and metadata inside the <code>site-packages</code>
folder.</li></ol><figure><img src=discover_pug.webp></figure><h1 id=python-package-types>Python package types
<a class=heading-link href=#python-package-types><i class="fa fa-link" aria-hidden=true></i></a></h1><p>A package during installation must generate at least two types of content to be put in the site package: a metadata
folder about the package contents the <code>{package}-{version}.dist-info</code> and the business logic files.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>/Users/bernat/Library/Python/3.7/lib/python/site-packages/pugs
├── __init__.py
├── __pycache__
│   ├── __init__.cpython-37.pyc
│   └── logic.cpython-37.pyc
└── logic.py
</code></pre></div><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>/Users/bernat/Library/Python/3.7/lib/python/site-packages/pugs-0.0.1.dist-info
├── INSTALLER
├── LICENSE.txt
├── METADATA
├── RECORD
├── WHEEL
├── top_level.txt
└── zip-safe
</code></pre></div><p>The distribution info folder describes the package: what installer was used to put it there, what license the package
has attached to it, what files were created as part of the installation process, what is the top-level python package,
what entry points the package exposes and so on. A good description of each file can be found inside
<a href=https://www.python.org/dev/peps/pep-0427/#id14>PEP-427</a>.</p><p>How do we get from our source tree to these two content types? We have two distinct paths in front of us:</p><ol><li>Generate this directory structure and metadata from our source tree, compress it into a single file, and publish it
to the central package repository. In this case, the installer has to download the package and extract it to the
<code>site-packages</code> folder. We refer to this type of package as a <code>wheel</code> package.</li><li>Alternatively, you can create an archive containing the package source, build scripts and metadata required to
generate the installable directory structure, then upload that to the central repository. This is called a source
distribution or <code>sdist</code>. In this case, the installer has a lot more work to do, extracts the archive, runs the
builder, and only then copies it over.</li></ol><p>The difference between the two options is mainly about where the package <em>compile/build</em> operation happens: the
developers' machine or the end-users machine. If it occurs on the developers' side (such as wheels), the installation
process is very lightweight. Everything has already been done on the developer machine side. The user machine side
operation is just a simple download and decompress.</p><p>In our case, we used <code>setuptools</code> as our builder (the part that generates from the source tree the content to be put
inside the site-packages folder). Therefore, to perform the build operation on the user machine, we would need to ensure
that an <em>appropriate</em> version of <code>setuptools</code> is available on the user machine (if you&rsquo;re using a feature from version
<code>40.6.0</code> you must guarantee that the user has at least that version).</p><p>Another use case to consider is that Python offers access to C/C++ libraries from within Python (to get that extra
performance where you need it). Packages that do so are referred to as C-extension packages, as they take advantage of
the C-extension API CPython offers.</p><p>Such extensions to work though, need to C/C++ compile their functionality against both the C/C++ library they interact
with and the current Python interpreters C-API library. In these cases, the build operation involves calling a binary
compiler, not just metadata and folder structure generation as was the case with pure python packages (such as our
<code>pugs</code> library was).</p><p>If the build happens on the user machine, one needs to ensure that the correct libraries and compilers are also
available at build time. This is now a much harder job, as these are platform-specific binaries distributed via the
platform&rsquo;s packaging tools. The lack or version miss-match of these libraries often triggers cryptic errors during the
build, which leaves users frustrated and puzzled.</p><p>Therefore, if possible, always prefer packaging your package as a <strong><em>wheel</em></strong>. This will altogether avoid the problem of
users not having all the correct build dependencies (both pure python types such as setuptools or binary ones as is the
C/C++ compiler). Even if those build dependencies are easy to provision (such as in the case of pure python builders -
e.g. setuptools) you can save install time by avoiding this step entirely.</p><p>That being said they are still two use cases that warrant providing source distributions (even when you provide a
wheel):</p><ol><li>C-extension source distributions tend to be more auditable, as one can read the source code and thus offer greater
transparency in what it offers: many big corporate environments prefer using these over wheels for this sole reason
(they generally extend the rule to pure python wheels, mostly to avoid the need of categorizing what is pure python
wheel and what is not).</li><li>You might not be able to provide a wheel for every possible platform out there (especially true in case of
c-extension packages), in this case, the source distribution may allow these platforms to generate the wheel
themselves.</li></ol><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h1><p>The difference between a source tree, a source distribution, and a wheel:</p><ul><li><strong>source tree <em>-</em></strong> contains all project files available on the developers' machine/repository (business logic, tests,
packaging data, CI files, IDE files, SVC, etc.) - for example, see example project above.</li><li><strong>source distribution</strong> - contains code files required to build a wheel (business logic + packaging data + often also
the unit tests files to validate the build; notably lacks developer environment content such as CI/IDE/version control
files) - format: <code>pugs-0.0.1.tar.gz</code>.</li><li><strong>wheel</strong> - contains the package metadata and source files to be put into the <code>site-packages</code> folder - format:
<code>pugs-0.0.1-py2.py3-none-any.whl</code>.</li></ul><figure><img src=smart_pug.webp></figure><p><a href=https://www.bernat.tech/pep-517-518/>Read the next post of the series here</a> to determine what happens when we install
a package. Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container><p>Software engineer <a href=https://github.com/bloomberg>at Bloomberg (London)</a>. Maintainer of <a href=https://github.com/gaborbernat/>many FOSS Python packages</a>. Opinions are my own.</p></section></footer></main><script src=/bernat-tech/js/coder.min.f92783b4545b68f3523e5d6ad91d93f76818f9d0db2ffa13bda31b6119cde62b.js integrity="sha256-+SeDtFRbaPNSPl1q2R2T92gY+dDbL/oTvaMbYRnN5is="></script></body></html>