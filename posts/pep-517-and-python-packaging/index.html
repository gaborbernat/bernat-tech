<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Bernát Gábor"><meta name=description content="pip 19.0 has been released on 22nd January 2019. On the feature list most notably it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed it up confirmed that many people are not at all familiar with it."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="The state of Python Packaging"><meta name=twitter:description content="pip 19.0 has been released on 22nd January 2019. On the feature list most notably it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed it up confirmed that many people are not at all familiar with it."><meta property="og:title" content="The state of Python Packaging"><meta property="og:description" content="pip 19.0 has been released on 22nd January 2019. On the feature list most notably it now supports PEP-517, which by default is turned on when that the project has a pyproject.toml at the root folder. The PEP in question has been created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues that followed it up confirmed that many people are not at all familiar with it."><meta property="og:type" content="article"><meta property="og:url" content="https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/"><meta property="article:published_time" content="2019-02-07T13:40:54+00:00"><meta property="article:modified_time" content="2019-02-07T13:40:54+00:00"><title>The state of Python Packaging · Tech articles by Bernát Gábor</title><link rel=canonical href=https://gaborbernat.github.io/bernat-tech/posts/pep-517-and-python-packaging/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=/bernat-tech/css/coder.min.f01c647a0d25b40da992a37c3376291185eed8a50ced8c26cc2c0bcfe38c97df.css integrity="sha256-8Bxkeg0ltA2pkqN8M3YpEYXu2KUM7YwmzCwLz+OMl98=" crossorigin=anonymous media=screen><link rel=stylesheet href=/bernat-tech/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin=anonymous media=screen><link rel=stylesheet href=/bernat-tech/css/custom.css><link rel=icon type=image/png href=/bernat-tech/img/android-chrome-192x192.png sizes=32x32><link rel=icon type=image/png href=/bernat-tech/img/android-chrome-192x192.png sizes=16x16><link rel=apple-touch-icon href=/bernat-tech/img/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=/bernat-tech/img/android-chrome-192x192.png><script src=https://twemoji.maxcdn.com/v/latest/twemoji.min.js crossorigin=anonymous></script><meta name=generator content="Hugo 0.78.2"></head><body class=colorscheme-auto onload=twemoji.parse(document.body);><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/bernat-tech>Tech articles by Bernát Gábor</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/bernat-tech/posts>Blog</a></li><li class=navigation-item><a class=navigation-link href=/bernat-tech/about>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>The state of Python Packaging</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2019-02-07T13:40:54Z>February 7, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>9-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/bernat-tech/tags/python/>python</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/packaging/>packaging</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pip/>pip</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/setuptools/>setuptools</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pep517/>pep517</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/pep518/>pep518</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/wheel/>wheel</a>
<span class=separator>•</span>
<a href=/bernat-tech/tags/sdist/>sdist</a></div></div></header><div><p>pip 19.0 has been released on 22nd January 2019. On the feature list most notably it now supports PEP-517, which by
default is turned <strong>on</strong> when that the project has a <code>pyproject.toml</code> at the root folder. The PEP in question has been
created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues
that followed it up confirmed that many people are not at all familiar with it. Read on if you want to get a picture of
how the Python packaging ecosystem evolved as of today and where we hope to see it down the line. We hope even though
the introduction of aforementioned python enhancement proposal may cause some discomfort at the moment, we will benefit
from it in the long term.</p><p>I&rsquo;ve joined the Python open source community around three years ago (though used it for more like 8 years). From the
early days I&rsquo;ve remarked that the Python packaging has a reputation of a kinda black box. There&rsquo;s a lot of unknown, and
people mostly get by with just copying other projects build configurations and roll with it. On my path to understand
better this black box and try to improve it I&rsquo;ve became the maintainer of both the virtualenv and tox project, with
occasionally contributing to both <code>setuptools</code> and <code>pip</code>.</p><p>As I hope to give an exhausting (hopefully still kinda high level) overview of the subject I decided to split it up in
three posts. In this first post I will give a broad overview of how Python packaging works along with the type of
packages it has. In a subsequent post I will present in detail how the installation of packages works, and how
PEP-517/518 tries to improve on it. Finally, I dedicate a whole other post to present some of the painful lessons we
learned while introducing these improvements. A heads up, I will focus mostly on the Python Packaging Authorities
systems (<code>pip</code>, <code>setuptools</code>, so no <code>conda</code> or operating system specific packagers).</p><p>{{/*&lt; figure src=&ldquo;<a href="https://images.unsplash.com/photo-1509037837816-6d0b98fcdf08?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ%22">https://images.unsplash.com/photo-1509037837816-6d0b98fcdf08?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ"</a> caption=&ldquo;Photo by Marcus Cramer / Unsplash - peoples face when they gaze into Python packaging first time&rdquo; */>}}</p><h1 id=an-example-project>An example project</h1><p>To tell this story, I&rsquo;ll need to tell the story of how to distribute python packages; more specifically explain how
package installation worked in the past and how we hope it will work in the future. To have a concrete example on what
to demonstrate, let me introduce my wonderful example library: <code>pugs</code>. This library reasonably simple: it just generates
a single package called <code>pugs</code> that contains only a single module called <code>logic</code>. The logic is to generate random
quotes, you guessed right, about <em>pugs</em>. Here&rsquo;s a simple example structure of it viewed as a source tree (also available
under <a href=https://github.com/gaborbernat/pugs>gaborbernat/pugs</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>pugs-project
├── README.rst
├── setup.cfg
├── setup.py
├── LICENSE.txt
├── src
│   └── pugs
│       ├── __init__.py
│       └── logic.py
├── tests
│   ├── test_init.py
│   └── test_logic.py
├── tox.ini
└── azure-pipelines.yml
</code></pre></div><p>We have four distinct content type here:</p><p>What would it mean for our <code>pugs</code> package to be available on a user machine&rsquo;s interpreter? Ideally, the user should be
able to import it and call functions from it once it starts up the interpreter:</p><ul><li>the business logic code (what&rsquo;s inside the <code>src</code> folder),</li><li>the test code (<code>tests</code> folder and <code>tox.ini</code>),</li><li>the packaging code and metadata (<code>setup.py</code>, <code>setup.cfg</code>, <code>LICENSE.txt</code>, <code>README.rst</code> - note we use nowadays the de
facto standard packaging tool <a href=https://pypi.org/project/setuptools>setuptools</a>),</li><li>files helping with project management and maintenance:<ul><li>continuous integration (<code>azure-pipelines.yml</code>)</li><li>version control (<code>.git</code>)</li><li>project management (for example a potential <code>.github</code> folder).</li></ul></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Python 3.7.2 (v3.7.2:9a3ffc0492, Dec 24 2018, 02:44:43)
[Clang 6.0 (clang-600.0.57)] on darwin
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; import pugs
&gt;&gt;&gt; pugs.do_tell()
&#34;An enlightened pug knows how to make the best of whatever he has to work with - A Pug&#39;s Guide to Dating -  Gemma Correll&#34;
</code></pre></div><p>{{/*&lt; figure src=&ldquo;<a href="https://images.unsplash.com/photo-1536351392281-79d89dd69869?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ%22">https://images.unsplash.com/photo-1536351392281-79d89dd69869?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ"</a> caption=&ldquo;Photo by Ryan Antooa / Unsplash - let&rsquo;s get started, excited!&rdquo; */>}}</p><h1 id=python-package-availability>Python package availability</h1><p>How does Python knows what&rsquo;s available or not? The short answer is it does not. Not upfront, at least, that is. Instead,
it will try to load and see if it succeeds dynamically. From where does it load it? There are many possible locations,
but in most cases, we are talking about loading it from a folder on the file system. Where is this folder? For a given
module, one can print out the representation of the module to find out:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>&gt;&gt;&gt; import pugs
&gt;&gt;&gt; pugs
&lt;module &#39;pugs&#39; from &#39;/Users/bernat/Library/Python/3.7/lib/python/site-packages/pugs/__init__.py&#39;&gt;
</code></pre></div><p>The folder under you&rsquo;ll find it depends on:</p><ul><li>the type of the package it is (third-party or built-in/aka part of the standard library)</li><li>if it&rsquo;s globally or just for the current user available (see <a href=https://www.python.org/dev/peps/pep-0370/>PEP-370</a>),</li><li>and if it&rsquo;s a system python or a virtual environment.</li></ul><p>Generally speaking though, for a given python interpreter, one can find a list of possible directories by printing out
the <code>sys.path</code> variables content, for example on my MacOS:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>&gt;&gt;&gt; import sys
&gt;&gt;&gt; print(&#39;\n&#39;.join(sys.path))
/Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip
/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7
/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload
/Users/bernat/Library/Python/3.7/lib/python/site-packages
/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages
</code></pre></div><p>For third-party packages, it&rsquo;s going to be some <code>site-packages</code> folder. Note in the above example how there&rsquo;s a
system-wide and a user-specific example of this. How does packages end up inside this folder? It must be put there by
some installer.</p><p>The following diagram displays how most of the time things go:</p><ol><li>The developer writes some python code inside a folder (referred to as the source tree).</li><li>Some tool (such as <code>setuptools</code>) then takes the source tree and packages it up for redistribution.</li><li>The generated package is uploaded via another tool (twine) to a central repository (usually
<a href=https://pypi.org>https://pypi.org</a>) the end user machine has access to.</li><li>The end user machine uses some installer that discovers, downloads and installs the package in question. The
installation operation boils down by creating the correct directory structure and metadata inside the <code>site-packages</code>
folder.</li></ol><p>{{/*&lt; figure src=&ldquo;<a href="https://images.unsplash.com/photo-1538131688925-7e0eb2e7828b?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ%22">https://images.unsplash.com/photo-1538131688925-7e0eb2e7828b?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ"</a> caption=&ldquo;Photo by Pinho . / Unsplash - discovering new things&rdquo; */>}}</p><h1 id=python-package-types>Python package types</h1><p>A package during installation must generate at least two types of content to be put in the site package: a metadata
folder about the package contents the <code>{package}-{version}.dist-info</code> and the business logic files.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>/Users/bgabor8/Library/Python/3.7/lib/python/site-packages/pugs
├── __init__.py
├── __pycache__
│   ├── __init__.cpython-37.pyc
│   └── logic.cpython-37.pyc
└── logic.py

/Users/bgabor8/Library/Python/3.7/lib/python/site-packages/pugs-0.0.1.dist-info
├── INSTALLER
├── LICENSE.txt
├── METADATA
├── RECORD
├── WHEEL
├── top_level.txt
└── zip-safe
</code></pre></div><p>The distribution info folder describes the package: what installer was used to put it there, what license the package
has attached to it, what files were created as part of the installation process, what is the top level python package,
what entry points the package exposes and so on. A good description of each file can be found inside
<a href=https://www.python.org/dev/peps/pep-0427/#id14>PEP-427</a>.</p><p>How do we get from our source tree to these two content type? We have two distinct paths in front of us:</p><ol><li>Generate this directory structure and metadata from our source tree, compress it into a single file and publish it to
the central package repository. In this case, the installer has to download the package and extract it to the
site-packages folder. We refer to this type of package as a <code>wheel</code> package.</li><li>Alternatively you can create an archive containing the package source, build scripts and metadata required to
generate the installable directory structure, then upload that to the central repository. This is called a source
distribution or <code>sdist</code>. In this case the installer has a lot more work to do, needs to extract the archive, run the
builder and only then copy it over.</li></ol><p>The difference between the two options is mainly about where the package <em>compile/build</em> operation happens: on the
developers' machine or the end users machine. If it happens on the developers' side (such as in the case of wheels), the
installation process is very lightweight. Everything has been already done on the developer machine side. The user
machine side operation is just a simple download and decompress.</p><p>In our case, we used <code>setuptools</code> as our builder (the part that generates from the source tree the content to be put
inside the site-packages folder). Therefore, in order to perform the build operation on the user machine we would need
to ensure that an <em>appropriate</em> version of <code>setuptools</code> is available on the user machine (if you&rsquo;re using a feature from
version <code>40.6.0</code> you must guarantee that the user has at least that version).</p><p>Another use case to consider is that Python offers the ability to access C/C++ libraries from within python (to get that
extra performance where you need it). Packages that do so are referred to as C-extension packages, as they take
advantage of the C-extension API CPython offers.</p><p>Such extensions to work though need to C/C++ compile their functionality against both the C/C++ library they interact
with and the current Python interpreters C-API library. In these cases the build operation actually involves calling a
binary compiler, not just metadata and folder structure generation as was the case with pure python packages (such as
our pugs library was).</p><p>If the build happens on the user machine one needs to ensure that the correct libraries and compilers are also available
at build time. This is now a much harder job, as these are platform specific binaries that are distributed via the
platforms packaging tools. The lack or version miss-match of these libraries often trigger cryptic errors during the
build, that leaves users frustrated and puzzled.</p><p>Therefore, if possible, always prefer packaging your package as a <strong><em>wheel</em></strong>. This will altogether avoid the problem of
users not having all the correct build dependencies (both pure python types such as setuptools or binary ones as is the
C/C++ compiler). Even if those build dependencies are easy to provision (such as in case of pure python builders - e.g.
setuptools) you can save install time by avoiding this step entirely.</p><p>That being said they are still two use cases that warrant providing source distributions (even when you provide a
wheel):</p><ol><li>C-extension source distributions tend to be more auditable, as one can read the source code and thus offer greater
transparency in what it offers: many big corporate environments prefer using these over wheels for this sole reason
(they generally extend the rule to pure python wheels too, mostly to avoid the need of categorizing what is pure
python wheel and what is not).</li><li>You might not be able to provide a wheel for every possible platform out there (especially true in case of
c-extension packages), in this case, the source distribution may allow these platforms to generate the wheel
themselves.</li></ol><p><strong>Conclusion</strong></p><p>The difference between a source tree, a source distribution and a wheel:</p><ul><li><strong>source tree <em>-</em></strong> contains all project files available on the developers' machine/repository (business logic, tests,
packaging data, CI files, IDE files, SVC etc.) - for example, see example project above.</li><li><strong>source distribution</strong> - __ contains code files required to build a wheel (business logic + packaging data + often
also the unit tests files to validate the build; notably lacks developer environment content such as CI/IDE/version
control files) - format: <code>pugs-0.0.1.tar.gz</code>.</li><li><strong>wheel</strong> - contains the package metadata and source files to be put into the site packages folder - format:
<code>pugs-0.0.1-py2.py3-none-any.whl</code>.</li></ul><p>{{/*&lt; figure src=&ldquo;<a href="https://images.unsplash.com/photo-1517423568366-8b83523034fd?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ%22">https://images.unsplash.com/photo-1517423568366-8b83523034fd?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ"</a> caption=&ldquo;Photo by Charles 🇵🇭 / Unsplash - hmmm&rdquo; */>}}</p><p><a href=https://www.bernat.tech/pep-517-518/>Read the next post of the series here</a> to find out what happens when we install a
package. Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container><p>Software engineer <a href=https://github.com/bloomberg>at Bloomberg (London)</a>. Maintainer of <a href=https://github.com/gaborbernat/>many FOSS Python packages</a>. Opinions are my own.</p></section></footer></main><script src=/bernat-tech/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script></body></html>