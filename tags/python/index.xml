<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Tech articles by Bern치t G치bor</title><link>https://bernat.tech/tags/python/</link><description>Recent content in Python on Tech articles by Bern치t G치bor</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 07 Sep 2024 10:37:56 -0700</lastBuildDate><atom:link href="https://bernat.tech/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Version numbers: how to use them?</title><link>https://bernat.tech/posts/version-numbers/</link><pubDate>Sat, 16 May 2020 14:15:00 +0000</pubDate><guid>https://bernat.tech/posts/version-numbers/</guid><description>&lt;p>The &lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" class="external-link" target="_blank" rel="noopener">DRY principle&lt;/a> (an acronym for don&amp;rsquo;t repeat yourself)
encourages software engineers to abstract code into a separate component and reuse it rather than write it over and over
again. If this happens across the system, the best practice is to put it inside a package that lives on its own (a
library) and then pull it in from the applications when required.&lt;/p>
&lt;p>As most of us can&amp;rsquo;t think of every feature that the library might offer or what bugs it might contain, these packages
tend to evolve. Therefore, we need some mechanism to encode these evolutions of the library, and most commonly, this is
a version number.&lt;/p></description></item><item><title>Python packaging - Growing Pains</title><link>https://bernat.tech/posts/growing-pain/</link><pubDate>Thu, 07 Feb 2019 13:41:03 +0000</pubDate><guid>https://bernat.tech/posts/growing-pain/</guid><description>&lt;p>In my previous two posts, I&amp;rsquo;ve gone over &lt;a href="https://bernat.tech/posts/pep-517-and-python-packaging/" >what package types python has&lt;/a>,
and &lt;a href="https://bernat.tech/posts/pep-517-518/" >how the package building works&lt;/a>, especially with the introduction of the PEP-517/518.
Although the changes were primarily to make things more robust, we did run into a few issues while implementing it and
releasing it. This post will go over a few, hopefully serving as lessons learned for all of us and presenting some
interesting problems to solve in the future.&lt;/p></description></item><item><title>Python packaging - Past, Present, Future</title><link>https://bernat.tech/posts/pep-517-518/</link><pubDate>Thu, 07 Feb 2019 13:40:59 +0000</pubDate><guid>https://bernat.tech/posts/pep-517-518/</guid><description>&lt;p>Have you ever wondered what happens exactly when you run pip install? This post will give you a detailed overview of the
steps involved in the past, and how it all changes with the adoption of PEP-517 and PEP-518.&lt;/p>
&lt;p>&lt;a href="https://bernat.tech/posts/pep-517-and-python-packaging/" >In my previous post&lt;/a> I&amp;rsquo;ve described how it&amp;rsquo;s possible to install three types
of content: source tree, source distribution, and wheels. Only the last two types are uploaded to PyPI, the central Python
repository. However, one could get its hands on a source tree (by feeding, for example, a git protocol for pip). The advantage
of wheels over the others is that it does not require any build operation to happen on the user machine; it&amp;rsquo;s just downloading
and extract.&lt;/p></description></item><item><title>The state of Python Packaging</title><link>https://bernat.tech/posts/pep-517-and-python-packaging/</link><pubDate>Thu, 07 Feb 2019 13:40:54 +0000</pubDate><guid>https://bernat.tech/posts/pep-517-and-python-packaging/</guid><description>&lt;p>pip 19.0 has been released on 22nd January 2019. On the feature list, most notably, it now supports PEP-517, which by
default is turned &lt;strong>on&lt;/strong> when that the project has a &lt;code>pyproject.toml&lt;/code> at the root folder. The PEP in question has been
created in 2015 and accepted in 2017. Even though it took a while until pip implemented it, the release and the issues
that followed confirmed that many people are not familiar with it. Read on if you want to get a picture of how the
Python packaging ecosystem evolved today and where we hope to see it down the line. We expect that even though the
introduction of the aforementioned python enhancement proposal may cause some discomfort, we will benefit from it in the
long term.&lt;/p></description></item><item><title>The state of type hints in Python</title><link>https://bernat.tech/posts/the-state-of-type-hints-in-python/</link><pubDate>Wed, 30 May 2018 09:51:55 +0000</pubDate><guid>https://bernat.tech/posts/the-state-of-type-hints-in-python/</guid><description>&lt;p>One of the main selling points for Python is that it is dynamically-typed. There is no plan to change this.
Nevertheless, in September 2014 &lt;a href="https://twitter.com/gvanrossum" class="external-link" target="_blank" rel="noopener">Guido van Rossum&lt;/a> (Python
&lt;a href="https://en.wikipedia.org/wiki/Benevolent_dictator_for_life" class="external-link" target="_blank" rel="noopener">BDFL&lt;/a>) created a python enhancement proposal
(&lt;a href="https://www.python.org/dev/peps/pep-0484" class="external-link" target="_blank" rel="noopener">PEP-484&lt;/a>) to add type hints to Python. It has been released for general
usage a year later, in September 2015, as part of Python &lt;code>3.5.0&lt;/code>.
&lt;a href="http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html" class="external-link" target="_blank" rel="noopener">Twenty-five years into its existence&lt;/a> now
there was a standard way to add type information to Python code. In this blog post, I&amp;rsquo;ll explore how the system matured,
how you can use it, and what&amp;rsquo;s next for type hints.&lt;/p></description></item></channel></rss>